To securely manage passwords in a **MERN** stack with **MongoDB** and **JWT**, follow these best practices:  

---

### **1. Hash Passwords Before Storing**
Never store raw passwords. Use **bcrypt** to hash passwords before saving them to the database.

#### **Install bcrypt**:
```sh
npm install bcrypt
```

#### **Modify Admin Schema (Hash Password Before Saving)**:
```javascript
import mongoose from "mongoose";
import bcrypt from "bcrypt";

const adminSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true,
        trim: true
    },
    password: {
        type: String,
        required: true
    }
}, { timestamps: true });

// Hash password before saving
adminSchema.pre("save", async function (next) {
    if (!this.isModified("password")) return next();
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
});

const Admin = mongoose.model("Admin", adminSchema);

export default Admin;
```

---

### **2. Validate Password on Login**
Use **bcrypt.compare()** to check the hashed password against user input.

#### **Example Login Logic:**
```javascript
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import Admin from "../models/Admin.js"; // Adjust path as needed

export const loginAdmin = async (req, res) => {
    const { name, password } = req.body;

    try {
        const admin = await Admin.findOne({ name });
        if (!admin) return res.status(400).json({ message: "User not found" });

        const isMatch = await bcrypt.compare(password, admin.password);
        if (!isMatch) return res.status(400).json({ message: "Invalid credentials" });

        const token = jwt.sign({ id: admin._id }, process.env.JWT_SECRET, { expiresIn: "1h" });

        res.json({ token, admin: { id: admin._id, name: admin.name } });
    } catch (error) {
        res.status(500).json({ message: "Server error" });
    }
};
```

---

### **3. Secure JWT Token Handling**
- Store `JWT_SECRET` in **environment variables** (`.env` file).
- Use **httpOnly cookies** to store tokens securely.

#### **Example `.env` File**:
```
JWT_SECRET=your_secret_key_here
```

#### **Install dotenv & Configure Server**:
```sh
npm install dotenv
```

```javascript
import dotenv from "dotenv";
dotenv.config();
```

---

### **4. Protect Routes (Middleware)**
Use **JWT middleware** to protect admin routes.

#### **Create `authMiddleware.js`**:
```javascript
import jwt from "jsonwebtoken";

const authMiddleware = (req, res, next) => {
    const token = req.header("Authorization");

    if (!token) return res.status(401).json({ message: "Access Denied" });

    try {
        const verified = jwt.verify(token, process.env.JWT_SECRET);
        req.user = verified;
        next();
    } catch (err) {
        res.status(400).json({ message: "Invalid Token" });
    }
};

export default authMiddleware;
```

#### **Use Middleware in Routes**:
```javascript
import express from "express";
import authMiddleware from "../middleware/authMiddleware.js";

const router = express.Router();

router.get("/admin-dashboard", authMiddleware, (req, res) => {
    res.json({ message: "Welcome, Admin!" });
});

export default router;
```

---

### **5. Secure Password Reset**
Use a **password reset token** (JWT or UUID) and send it via email.

1. Generate a **reset token**.
2. Store it temporarily in the database (expires after 15 mins).
3. Send an email with a reset link.
4. Verify the token and update the password.

---

### **Final Security Best Practices**
âœ… Use **https-only cookies** for JWT storage.  
âœ… **Never expose JWT secrets** in frontend code.  
âœ… Use **Helmet, CORS, and Rate Limiting** for API security.  
âœ… Rotate **JWT secrets** periodically.  
âœ… Implement **two-factor authentication (2FA)** if necessary.  

---

Let me know if you need a full working example! ðŸš€